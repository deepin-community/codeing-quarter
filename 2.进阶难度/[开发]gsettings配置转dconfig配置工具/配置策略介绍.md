#配置策略使用说明

##配置介绍

配置策略涉及主要包括配置描述文件(meta)、配置存储文件(cache)、覆盖机制配置文件(override)，
应用需要配置的为meta和override（可选）文件，它们均为json格式的文件。

### meta

配置描述文件：由应用安装时部署，用于描述配置项的元信息，以及携带配置项的默认值，标志信息为 "magic": "dsg.config.meta"。

- magic：此 json 文件的标识性信息，所有描述文件均标记为 “dsg.config.meta”
- version：此描述文件的内容格式的版本。版本号使用两位数字描述，首位数字不同的描述文件相互之间不兼容，第二位数字不同的描述文件需满足向下兼容。解析此描述文件的程序要根据版本进行内容分析，当遇到不兼容的版本时，需要立即终止解析，并向使用者报告错误信息，如 “1.0” 和 “2.0” 版本之间不兼容，如果解析程序最高只支持 1.0 版本，则遇到 2.0 版本的描述文件时应该报告错误，但是如果遇到 1.1 版本，则可以继续执行。
- contents：配置项的内容，每一个配置项是一个 json 对象，配置项之间的相对顺序无意义，且不支持嵌套。
  - value：配置项的默认值，可使用 json 支持的各种数据类型，如字符串、数字、数组、对象等
  - serial：单调递增的整数值，使用场景：假设程序 “A” 的配置项 “a” 记录其是否已经进行了初始化，之后 “A” 可能更改了初始化相关的代码，需要确保版本更新之后能重新进行初始化，则可以将配置项 “a” 的 “serial” 属性增加 1，则旧版 “A” 程序所记录的配置项 “a” 将失效，以此确保更新 “A” 之后能再次进行初始化工作。此配置项可以省略，无此项时读取配置存储文件将忽略 serial 字段。
  - name：配置项的可显示名称，需国际化（使用DTK工具为其生成 ts 文件，ts 编译后的 qm 文件需要与配置描述文件同名同路径放置）。此名称可用于展示到用户界面，如当程序 A 请求通过配置中心读取程序 B 的某个配置项时，将提示用户“程序 A 请求获取程序 B 的"允许退出"配置项的值，是否允许？”，用户可选择拒绝程序 A 的请求，名称在这里的作用是利于用户理解此配置项的含义。
  - description：描述此配置项的用途，需国际化（同 name)。
  - permissions：配置项的权限。
  readonly：不允许修改，当程序读取此配置时，将直接使用默认值。
  readwrite：可读可写，如果此值被修改过，则不再使用此处定义的默认值。

  - visibility：配置项的可见性
  private 仅限程序内部使用，对外不可见。此类配置项完全由程序自己读写，可随意增删改写其含义，无需做兼容性考虑。
  public 外部程序可使用。此类配置项一旦发布，在兼容性版本的升级中，要保障此配置项向下兼容，简而言之，只允许在程序/库的大版本升级时才允许删除或修改此类配置项，当配置项的 permissions、visibility、flags 任意一个属性被修改则认为此配置项被修改，除此之外修改 value、name、description 属性时则不需要考虑兼容性。

  - flags：配置项的一些特性
    - nooverride：存在此标记时，将表明则此配置项不可被覆盖（详见下述 override 机制）。反之，不存在此标记时表明此配置项允许被覆盖，对于此类配置项，如若其有界面设置入口，则当此项不可写时，应当隐藏或禁用界面的设置入口。
    - global：当读写此类配置时，将忽略用户身份，无论程序使用哪个用户身份执行，读操作都将获取到同样的数据，写操作将对所有用户都生效。但是，如果对应的配置存储目录不存在或无权限写入，则忽略此标志。

### override

override 文件：当描述文件中的flags没有nooverride标记时，override目录下的配置可覆盖配置项的同名属性，标志信息为 "magic": "dsg.config.override"


覆盖机制文件为json类型文件，这是配置策略遵守的配置覆盖文件格式，具体字段如下：
- magic：此 json 文件的标识性信息，所有 override 文件均标记为 “dsg.config.override”
- version：此文件的内容格式的版本。版本号使用两位数字描述，首位数字不同的描述文件相互之间不兼容，第二位数字不同的描述文件需满足向下兼容。解析此描述文件的程序要根据版本进行内容分析，当遇到不兼容的版本时，需要立即终止解析，忽略此文件，并在程序日志中写入警告信息，如 “1.0” 和 “2.0” 版本之间不兼容，如果解析程序最高只支持 1.0 版本，则遇到 2.0 版本的描述文件时应该终止解析，但是如果遇到 1.1 版本，则可以继续执行。
- contents：覆盖的配置项的内容，每一项是一个 json 对象，项之间的相对顺序无意义。
  - value：覆盖配置项的默认值。
  - serial：覆盖配置项对应的 serial 属性。
  - comment：描述此 override 行为的注释内容。
  - permissions：覆盖配置项的权限。
    - readonly：将配置项覆盖为只读
    - readwrite：将配置项覆盖为可读可写

### cache

配置存储文件：对于一些可修改的配置项，此文件用于保存程序运行过程中的改动，根据配置项是否携带 global 标志，将分开存储，标志信息为 "magic": "dsg.config.cache"。

- magic：此 json 文件的标识性信息，所有存储文件均标记为 “dsg.config.cache”
- version：此文件的内容格式的版本。版本号使用两位数字描述，首位数字不同的描述文件相互之间不兼容，第二位数字不同的描述文件需满足向下兼容。读取此描述文件的程序要根据版本进行内容分析，当遇到不兼容的版本时，需要立即终止解析，忽略此文件，并在程序日志中写入警告信息，如 “1.0” 和 “2.0” 版本之间不兼容，如果解析程序最高只支持 1.0 版本，则遇到 2.0 版本的描述文件时应该终止解析，但是如果遇到 1.1 版本，则可以继续执行。写入此描述文件时，遇到不兼容的版本时，需要先清空当前内容再写入，每次写入皆需更新此字段。
- contents：保存的配置项的内容，每一项是一个 json 对象，项之间的相对顺序无意义。
  - value：保存修改后的值
  - serial：在使用此配置项的存储值之前，应当先与配置描述文件中定义的 serial 属性做比较（需遵守 override 机制），如果此值不等于配置表述文件中记录的值，否则忽略此处存储的值
  - time：记录值的修改时间，使用 UTC 时间，采用 ISO 8601 表示方法
  - user：记录修改此项设置的用户名称
  - appid：记录修改此项设置的应用程序id，如无法正常获取程序id，需记录二进制文件路径

## 配置规范

### 变量说明

*${appid}: 应用ID
*${configuration_id}：配置描述文件ID，值为配置描述文件名
*${subpath}: 子路径
*${override_id}: override文件ID，值为override文件名

### 配置文件命名

应用需要设置的配置文件分为两类，应用配置文件和公共库配置文件，它们均以`.json`为后缀，utf8格式编码文件名组成有所不同。

*配置描述文件，文件名分为两部分组成，一部分包含共库所属组织ID、开发库或应用ID，另一部分为配置文件含义，当无特殊含义时，这部分可以省略，中间以`.`连接。例如dtkcore开发库的配置文件: 通用配置时文件名可以使用 org.deepin.dtk.core.json， 如果此配置文件仅用来控制单一的功能，可在名称中得以体现，例如控制DTK程序的日志输出规则的配置项，可以使用 org.deepin.dtk.core.log.json 作为配置文件名称；dde-dock应用的公共配置文件名可以使用org.deepin.dock.json，若仅控制管理窗口信息的配置文件，配置文件名可以使用org.deepin.dock.window.json。
*override文件，文件名只允许使用[拉丁字符](https://unicode-table.com/en/blocks/basic-latin/)。使用[自然排序](http://www.naturalordersort.org/)（如“a2”在“a11”之前）规则，按文件名排序，越靠后的配置文件优先级越高。
*子路径，子路径推荐以`下划线命名法`命名。

-----------------

### 配置文件存储路径

配置文件相关的路径按文件种类分为三类，其中配置描述文件和override文件需要应用配置，安装到指定位置，配置存储文件是配置策略服务自行指定的。

#### 配置描述文件

配置描述文件按功能分为应用文件和公共库文件，均安装在/usr/share/dsg/configs/目录下。

*应用配置描述文件:

    * /usr/share/dsg/configs/${appid}/[${subpath}]/${configuration_id}.json。例如dock应用的配置描述文件放置在/usr/share/dsg/configs/dock/org.deepin.dock.json，若有针对dtkcore开发库的log覆盖配置描述文件，可以放置在/usr/share/dsg/config/dock/org.deepin.dtk.core.log.json。

*开发库配置描述文件:

    * /usr/share/dsg/configs/[${subpath}]/${configuration_id}.json。例如dtkcore开发库的配置描述文件放置在/usr/share/dsg/config/org.deepin.dtk.core.json, 针对log配置的配置描述文件放置在/usr/share/dsg/config/org.deepin.dtk.core.log.json。

#### override文件

override文件安装在以下路径，override文件查找机制顺序优先级排序。

1. /etc/dsg/configs/overrides/${appid}/${configuration_id}/[${subpath}]/${override_id}.json
2. /usr/share/dsg/configs/overrides/${appid}/${configuration_id}/[${subpath}]/${override_id}.json
3. /etc/dsg/configs/overrides/${configuration_id}/[${subpath}]/${override_id}.json
4. /usr/share/dsg/configs/overrides/${configuration_id}/[${subpath}]/${override_id}.json

/usr用于于放置安装包携带的文件 ，/etc 下的路径用于放置动态创建的文件，比如用户手动添加，或者域管等程序在运行时创建。

例如，通过override机制，当需要覆盖dock应用的org.deepin.dock.window.json时，我们可以放置/etc/dsg/configs/overrides/dock/org.deepin.dock.window/window.json文件，window.json会尝试覆盖org.deepin.dock.window.json配置描述文件里相同的配置项。

#### 配置存储文件

*user级别的配置项所处的配置存储文件:$HOME/.config/dsg/configs/${appid}/${configuration_id}.json
*global级别的配置项所处的配置存储文件:/var/dsg/appdata/configs/${configuration_id}.json

### 配置项各字段

*`key`命名以`小驼峰法标识`命名，否则在某些场景下导致此项会无法正常使用。e.g: showWindowName。
*`value`默认值与所属类型一致，当更新时与默认值类型不一致时，会判断类型是否兼容，做隐式转换。e.g:字符串类型: "value": "", bool类型: "value": false, int，double类型: "value": 1.0，数组类型: "value": []， 键值对类型: "value": {}。
*`name`和`description`，建议设默认为中文， e.g: "name": "我是名字"，中文："name[zh_CN]": "我是名字"， 英文:"name[en_US]": "I am name"。
*`visibility`按最小权限为标准，默认权限设置为"private"类型，e.g: "visibility": "private"
*`flags`默认设为允许被覆盖，不确定是否是全局配置时，不要添加"global"标志，建议设为允许被覆盖，e.g: "flags": []。
*`permissions`，不确定是否只读时，建议设为允许读写， e.g: "permissions": "readwrite"

##前端使用

### 配置项定义

#### 定义meta

- 示例:$Repo/configs/dconf-example.json
```json
{
    "magic": "dsg.config.meta",
    "version": "1.0",
    "contents": {
        "canExit": {
            "value": true,
            "serial": 0,
            "flags": ["global"],
            "name": "I am name",
            "name[zh_CN]": "我是名字",
            "description": "I am description",
            "permissions": "readwrite",
            "visibility": "private"
        },
        "key2": {
            "value": "125",
            "serial": 0,
            "flags": ["nooverride"],
            "name": "I am name",
            "name[zh_CN]": "我是名字",
            "description": "I am description",
            "permissions": "readwrite",
            "visibility": "public"
        },
        "key3": {
            "value": "application",
            "serial": 0,
            "flags": ["global"],
            "name": "I am name",
            "name[zh_CN]": "我是名字",
            "description": "I am description",
            "permissions": "readwrite",
            "visibility": "public"
        }
    }
}
```

#### 定义override

- 示例:$Repo/configs/a/dconf-example.override.a.json
```json
{
    "magic": "dsg.config.override",
    "version": "1.0",
    "contents": {
        "key3": {
            "value": "override /a",
            "serial": 0,
            "permissions": "readwrite"
        }
    }
}
```

### 安装路径

使用dtkcommon提供的prf变量或cmake函数来指定部署位置，使用`sudo make install`安装到约定位置.

#### 部署meta

可部署多个meta类型的配置描述文件，其中【base】可选，【appid】和【commonid】设置其中一项，当【commonid】设置为非空时，meta作为公共库描述文件使用，作用于所有的应用。

##### qmake工程管理

```pro

#files       - deployed files.
#base        - used to get subpath, if it's empty, only copy files, and ignore it's subpath structure.
#appid       - working for the app, if it's empty, depending on `TEMPLATE`.
#commonid    - working for common, if it's empyt, depending on `TEMPLATE`.

#/a为子目录

meta_file.files += \
  configs/example.json \
  configs/a/example.json

meta_file.base = $$PWD/configs

DCONFIG_META_FILES += meta_file
load(dtk_install_dconfig)
```

##### cmake工程管理

```CMakeLists.txt

#FILES       - deployed files.
#BASE        - used to get subpath, if it's empty, only copy files, and ignore it's subpath structure.
#APPID       - working for the app.
#COMMONID    - working for common.

#/a为子目录

dconfig_meta_files(APPID dconfigexample BASE ./configs FILES ./configs/example.json ./configs/a/example.json)
```

####部署override

可部署多个override类型的覆盖文件，其中【base】、【appid】可选，当【base】为空时，没有子目录结构。

#####qmake工程管理

```pro

#files       - deployed files.
#base        - used to get subpath, if it's empty, only copy files, and ignore it's subpath structure.
#appid       - working for the app, if it's empty, working for all app.
#meta_name   - override for the meta configure.

#/a/b为子目录

override_file.files += \
    configs/dconf-example.override.json \
    configs/a/dconf-example.override.a.json \
    configs/a/b/dconf-example.override.a.b.json

override_file.base = $$PWD/configs
override_file.meta_name = example
override_file.appid = $$TARGET

DCONFIG_OVERRIDE_FILES += override_file
load(dtk_install_dconfig)
```

#####cmake工程管理

```CMakeLists.txt

#FILES       - deployed files.
#BASE        - used to get subpath, if it's empty, only copy files, and ignore it's subpath structure.
#APPID       - working for the app, if it's empty, working for all app.
#META_NAME   - override for the meta configure.

#/a/b为子目录

dconfig_override_files(APPID dconfigexample BASE ./configs META_NAME example  FILES ./configs/dconf-example.override.json ./configs/a/dconf-example.override.a.json)
```

###开发库API接口

通过DTK::Core::DConfig类来使用配置策略。
```c++
// 构造DConfig
DConfig config(fileName);

// 判断是否有效
if (!config.isValid()) {
    qWarning() << QString("DConfig is invalide, name:[%1], subpath[%2].").arg(config.name(), config.subpath());
    return;
}

// 获取所有配置项的key
const QStringList &keyList = config.keyList();

// 获取指定配置项的值
const bool value = config.value("canExit").toBool();

// 设置值指定配置项的值
config.setValue("canExit", false);

// 监听值改变的信号
QObject::connect(&config, &DConfig::valueChanged, [](const QString &key){});
```

***DConfig是在析构时保存设置修改的缓存信息，只有DConfig正常析构, 缓存信息才能写入磁盘***

## 后端使用

### 配置项定义

与前端使用配置项相同

### 安装路径

无法使用dtkcommon提供的默认安装路径，按约定放置在特定路径下，`[]`表示可选，  
可参照libdtkcommon-dev的`DtkInstallDConfigConfig.cmake`或`dtk_install_dconfig.prf`实现

#### meta

- 应用: /usr/share/dsg/apps/应用名/configs/[子目录名]/配置文件名.json，
之后切换到目录：opt/apps/应用名/files/schemas/configs/[子目录名]/配置文件名.json。

- 公共库: $DSG_DATA_DIR/configs/[子目录名]/配置文件名.json
  
***当公共库与应用的配置文件同名,则用应用配置文件***

***$DSG_DATA_DIR值为空时，默认为`/usr/share/dsg`***

#### override

- $DSG_DATA_DIR/configs/overrides/[应用名]/配置文件名/[子目录名]/override文件名.json

#### cache

cache路径不需要配置，这里只是说明cache将要保存的位置。

- user:$HOME/.config/应用名/配置文件名.json
- global:$DSG_APP_DATA/configs/配置文件名.json

### 开发库API接口

只能通过 `dbus` 协议访问配置中心来访问配置策略，
访问配置项需要两步，先调用`acquireManager`获得`dbus配置路径`，再通过`dbus资源路径`访问具体配置项。

- 资源管理接口
```xml
<interface name='org.desktopspec.ConfigManager'>
    <method name='acquireManager'>
      <arg type='s' name='appid' direction='in'/>
      <arg type='s' name='name' direction='in'/>
      <arg type='s' name='subpath' direction='in'/>
      <arg type='o' name='path' direction='out'/>
    </method>
    <method name='update'>
    <arg type='s' name='name' direction='in'/>
    </method>
</interface>
```

- 资源访问
```xml
<interface name='org.desktopspec.ConfigManager.Manager'>
    <property access="read" type="s" name="version"/>
    <property access="read" type="as" name="keyList"/>
    <method name='value'>
      <arg type='s' name='key' direction='in'/>
      <arg type='v' name='value' direction='out'/>
    </method>
    <method name='setValue'>
      <arg type='s' name='key' direction='in'/>
      <arg type='v' name='value' direction='in'/>
    </method>
    <method name='name'>
      <arg type='s' name='key' direction='in'/>
      <arg type='s' name='language' direction='in'/>
      <arg type='s' name='name' direction='out'/>
    </method>
    <method name='description'>
      <arg type='s' name='key' direction='in'/>
      <arg type='s' name='language' direction='in'/>
      <arg type='s' name='description' direction='out'/>
    </method>
    <method name='visibility'>
      <arg type='s' name='key' direction='in'/>
      <arg type='s' name='visibility' direction='out'/>
    </method>
    <method name='permissions'>
      <arg type='s' name='key' direction='in'/>
      <arg type='s' name='permissions' direction='out'/>
    </method>
    <!--采用引用计数的方式，引用为 0 时才真正的销毁-->
    <method name='release'>
    </method>
    <signal name="valueChanged">
      <arg name="key" type="s" direction="out"/>'
    </signal>
</interface>
```

- `dbus-send` 访问配置中心

`dbus-send` 使用 `acquireManager` 返回资源路径时，进程退出，导致资源被立即释放，需要开启配置中心延迟释放资源功能(设置-t选项，`dconfig-daemon -t 100`，会延迟 100ms 释放资源)。

``` bash
  #!/bin/bash

  #acquireManager
  DCONFIG_RESOURCE_PATH=$(dbus-send --system --type=method_call --print-reply=literal --dest=org.desktopspec.ConfigManager / org.desktopspec.ConfigManager.acquireManager string:'dconfigclient' string:'example' string:'')''

  #object path
  echo path: $DCONFIG_RESOURCE_PATH

  #monitor valueChanged
  dbus-monitor --system "type='signal', interface='org.desktopspec.ConfigManager.Manager',member=valueChanged" &

  #description
  dbus-send --system --type=method_call --print-reply --dest=org.desktopspec.ConfigManager $DCONFIG_RESOURCE_PATH org.desktopspec.ConfigManager.Manager.description string:'canExit' string:

  #name默认语言
  dbus-send --system --type=method_call --print-reply --dest=org.desktopspec.ConfigManager $DCONFIG_RESOURCE_PATH org.desktopspec.ConfigManager.Manager.name string:'canExit' string:

  #name中文
  dbus-send --system --type=method_call --print-reply --dest=org.desktopspec.ConfigManager $DCONFIG_RESOURCE_PATH org.desktopspec.ConfigManager.Manager.name string:'canExit' string:'zh_CN'

  #visibility
  dbus-send --system --type=method_call --print-reply --dest=org.desktopspec.ConfigManager $DCONFIG_RESOURCE_PATH org.desktopspec.ConfigManager.Manager.visibility string:'canExit'

  #permissions
  dbus-send --system --type=method_call --print-reply --dest=org.desktopspec.ConfigManager $DCONFIG_RESOURCE_PATH org.desktopspec.ConfigManager.Manager.permissions string:'canExit'

  #value
  dbus-send --system --type=method_call --print-reply --dest=org.desktopspec.ConfigManager $DCONFIG_RESOURCE_PATH org.desktopspec.ConfigManager.Manager.value string:'canExit' 

  #setValue
  PROPERTY_VALUE=$(dbus-send --system --type=method_call --print-reply=literal --dest=org.desktopspec.ConfigManager $DCONFIG_RESOURCE_PATH org.desktopspec.ConfigManager.Manager.value string:'canExit')  
  if [[ "$PROPERTY_VALUE" = *true ]] ;then 
    dbus-send --system --type=method_call --print-reply --dest=org.desktopspec.ConfigManager $DCONFIG_RESOURCE_PATH org.desktopspec.ConfigManager.Manager.setValue string:'canExit' variant:boolean:false
  else  
    dbus-send --system --type=method_call --print-reply --dest=org.desktopspec.ConfigManager $DCONFIG_RESOURCE_PATH org.desktopspec.ConfigManager.Manager.setValue string:'canExit' variant:boolean:true
  fi

  #value
  dbus-send --system --type=method_call --print-reply --dest=org.desktopspec.ConfigManager $DCONFIG_RESOURCE_PATH org.desktopspec.ConfigManager.Manager.value string:'canExit' 

  #update
  dbus-send --system --type=method_call --print-reply --dest=org.desktopspec.ConfigManager / org.desktopspec.ConfigManager.update string:'/usr/share/dsg/apps/dconfig-example/configs/example.json'

  #release
  dbus-send --system --type=method_call --print-reply --dest=org.desktopspec.ConfigManager $DCONFIG_RESOURCE_PATH org.desktopspec.ConfigManager.Manager.release

  jobs -p |xargs kill 
  ```

##dde-config

dde-config 是一个命令行工具，主要用于通过命令行的方式，浏览和设置应用的配置项。dde-dconfig-editor工具的复制和导出的命令都是通过执行该工具完成的。
安装 dconfig-daemon 的时候会自动安装该工具。

该工具的 Options 可以通过 --help 查看，其中三个常用命令行(以 dconfig-example 举例)：

- 设置配置项: dde-dconfig --set -a dconfig-example -r example -k advance.cursor.radiogroup -v 0
- 查看配置项: dde-dconfig --get -a dconfig-example -r example -k advance.cursor.radiogroup
- 浏览应用所有配置: dde-dconfig --list -a dconfig-example
- 启动 dde-dconfig-editor: dde-dconfig --gui

（-a 应用名 -r 资源名 -k 配置项的key -v 配置项的value）

##安装依赖包

- 安装依赖开发包，`dde-dconfig-daemon`为配置中心，提供dbus接口
```bash
sudo apt install libdtkcommon libdtkcore5 libdtkcore-dev dde-dconfig-daemon
```

- 工具包来编辑配置项[可选]
```bash
sudo apt install dde-dconfig-editor
```

##dpkg安装更新

制作一个deb trigger，在更新安装包时，可不重启配置中心来更新对应的配置资源服务。在包里$Repo/debian/postinst脚本添加dbus请求，来更新配置中心的对应配置资源服务。

```postinst
  #!/bin/bash

#`/usr/share/dsg/apps/dconfig-example/configs/example.json`为需要更新的配置描述文件.

  dbus-send --system --type=method_call --print-reply --dest=org.desktopspec.ConfigManager / org.desktopspec.ConfigManager.update string:'/usr/share/dsg/apps/dconfig-example/configs/example.json'
```

##与 DSettings 的区别

`DSettings` 虽然也是通过 `json` 作为配置文件，也有 `set/get` 和设置后端 `backend` 等接口，但是 `DSettings` 主要是设计来给 `DSettingsDialog`  用的，通过 `json` 来生成设置对话框的一种工具类，如果需要保存这些配置需要自行管理配置文件。而 `DConfig` 作为配置策略规范的实现，为了统一管理系统中应用的配置项而生，使用这个来配置应用之后，可以方便统一管理系统中各应用的配置项，按照规范放置配置文件后，应用只需关心 `DConfig` 这个类，并且还支持 `subpath` 和 `override` 机制方便定制。

###已经使用了DSettings 的应用如何迁移

- 按照本文中描述增加 `meta` 或者 `override` 配置文件。
- 在  `DSettings` 的 `backend` 中做适配将原来设置和获取的接口。
 - `dtkcore` 将提供一个 `DSettingsDConfigBackend` ，应用可以使用这个。
 - 配置数据迁移，当启动时发现有旧的配置文件时先将配置都获取出来，然后设置到 `DSettingsDConfigBackend` 中，迁移完之后删除旧的配置文件即可。

可以查看下方参考文档里面“使用的demo”的例子。

##如何OEM

通常OEM定制镜像中客户可能会要求一些应用功能默认关闭或者开启，值得注意的时这种定制只会影响初始行为，也就是镜像安装之后首次启动的默认行为，之后使用者的手动改变配置行为不在本次讨论范围之类。针对需要做OEM定制的客户，可以将一些需要定制的配置作为 `override` 项预装到系统镜像中，这样应用启动时默认行为会优先从 `override` 配置项中来读取。举例说明： 应用A可以配置启动时是正常大小、最大化或者全屏，uos镜像中默认时正常大小，有客户希望OEM镜像中打开时默认最大化并且无法修改，此时就可以通过国 `override` 这个配置来实现，将默认配置 `onstart` 由 `window_normal` 重载为  `window_maximum` ，并将  `permissions` 由 `readwrite` 重载为 `readonly`， 这样之后在定制镜像中应用打开就是最大化，并且就算设置了正常窗口也不会更改配置，这里应用还可以根据是否 `readonly` 禁用控件。


```json
meta 配置
{
  "magic": "dsg.config.meta",
  "version": "1.0",
  "contents": {
      "window": {
          "onstart": "window_normal",
          "name": "window state on start",
          "name[zh_CN]": "启动时窗口状态",
          "description": "此配置可以修改应用启动时的窗口大小，如正常窗口、最大化或者全屏",
          "permissions": "readwrite"
      }
  }
}

定制 override
{
  "magic": "dsg.config.override",
  "version": "1.0",
  "contents": {
      "window": {
          "onstart": "window_maximum",
          "name": "window state on start",
          "name[zh_CN]": "启动时窗口状态",
          "description": "此配置可以修改应用启动时的窗口大小，如正常窗口、最大化或者全屏",
          "permissions": "readonly"
      }
  }
}
```

## 临时问题

- 应用使用`DConfig`接口时和单元测试测试使用了`DConfig`接口时，传递的`appid`为qApp的applicationName，当appid与应用名称不一致时，需要设置应用名称为appid。
```c++
    qApp->setApplicationName(appid);
    DConfig handler(configuration_id);
```
   或者
```c++
   DConfig *handler = Dconfig::create(appid, configuration_id);
```

